-- =================================================================
-- CORREÇÃO FINAL - Script Ultra-Simplificado
-- Execute este script SEÇÃO POR SEÇÃO no SQL Editor do Supabase
-- =================================================================

-- SEÇÃO 1: LIMPEZA TOTAL (execute primeiro)
DROP TABLE IF EXISTS public.dados_corridas CASCADE;

-- SEÇÃO 2: CRIAR TABELA (execute depois da limpeza)
CREATE TABLE public.dados_corridas (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    data_do_periodo DATE,
    periodo TEXT,
    duracao_do_periodo TEXT,
    numero_minimo_de_entregadores_regulares_na_escala INTEGER,
    tag TEXT,
    id_da_pessoa_entregadora TEXT,
    pessoa_entregadora TEXT,
    praca TEXT,
    sub_praca TEXT,
    origem TEXT,
    tempo_disponivel_escalado TEXT,
    tempo_disponivel_absoluto TEXT,
    numero_de_corridas_ofertadas INTEGER,
    numero_de_corridas_aceitas INTEGER,
    numero_de_corridas_rejeitadas INTEGER,
    numero_de_corridas_completadas INTEGER,
    numero_de_corridas_canceladas_pela_pessoa_entregadora INTEGER,
    numero_de_pedidos_aceitos_e_concluidos INTEGER,
    soma_das_taxas_das_corridas_aceitas NUMERIC(10,2),
    -- colunas derivadas para performance
    duracao_segundos NUMERIC,
    tempo_disponivel_escalado_segundos NUMERIC,
    tempo_disponivel_absoluto_segundos NUMERIC,
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- SEÇÃO 3: PERMISSÕES (execute depois da tabela)
ALTER TABLE public.dados_corridas ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Enable read access for all users"
ON public.dados_corridas
FOR SELECT
USING (true);

CREATE POLICY "Enable insert for anon users"
ON public.dados_corridas
FOR INSERT
WITH CHECK (true);

-- SEÇÃO 4: FUNÇÕES AUXILIARES E TRIGGER (execute depois das permissões)
CREATE OR REPLACE FUNCTION public.normalize_time_to_hhmmss(input_value text)
RETURNS text
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  result text := '00:00:00';
BEGIN
  IF input_value IS NULL OR trim(input_value) = '' THEN
    RETURN result;
  END IF;

  input_value := trim(input_value);

  IF input_value LIKE '%T%:%:%Z' THEN
    result := split_part(split_part(input_value, 'T', 2), '.', 1);

  ELSIF input_value ~ '^[0-9]+\\.[0-9]+$' THEN
    DECLARE
      total_seconds int := round((input_value::numeric * 86400)::numeric);
      hours int := floor(total_seconds / 3600);
      minutes int := floor((total_seconds % 3600) / 60);
      seconds int := total_seconds % 60;
    BEGIN
      result := lpad(hours::text, 2, '0') || ':' ||
                lpad(minutes::text, 2, '0') || ':' ||
                lpad(seconds::text, 2, '0');
    END;

  ELSIF input_value ~ '^[0-9]{1,2}:[0-9]{2}:[0-9]{2}$' THEN
    result := input_value;

  ELSE
    result := input_value;
  END IF;

  RETURN result;
END $$;

CREATE OR REPLACE FUNCTION public.hhmmss_to_seconds(input_value text)
RETURNS numeric
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  hh int;
  mm int;
  ss int;
BEGIN
  IF input_value IS NULL OR trim(input_value) = '' THEN
    RETURN 0;
  END IF;

  BEGIN
    RETURN EXTRACT(EPOCH FROM input_value::interval);
  EXCEPTION WHEN others THEN
    BEGIN
      SELECT split_part(input_value, ':', 1)::int,
             split_part(input_value, ':', 2)::int,
             split_part(input_value, ':', 3)::int
      INTO hh, mm, ss;
      RETURN (hh * 3600 + mm * 60 + ss);
    EXCEPTION WHEN others THEN
      RETURN 0;
    END;
  END;
END $$;

CREATE OR REPLACE FUNCTION public.normalize_time_columns_trigger()
RETURNS trigger
LANGUAGE plpgsql
AS $$
DECLARE
  duracao_norm text;
  escalado_norm text;
  absoluto_norm text;
BEGIN
  duracao_norm := public.normalize_time_to_hhmmss(NEW.duracao_do_periodo);
  escalado_norm := public.normalize_time_to_hhmmss(NEW.tempo_disponivel_escalado);
  absoluto_norm := public.normalize_time_to_hhmmss(NEW.tempo_disponivel_absoluto);

  NEW.duracao_do_periodo := duracao_norm;
  NEW.tempo_disponivel_escalado := escalado_norm;
  NEW.tempo_disponivel_absoluto := absoluto_norm;

  NEW.duracao_segundos := public.hhmmss_to_seconds(duracao_norm);
  NEW.tempo_disponivel_escalado_segundos := public.hhmmss_to_seconds(escalado_norm);
  NEW.tempo_disponivel_absoluto_segundos := public.hhmmss_to_seconds(absoluto_norm);

  RETURN NEW;
END $$;

CREATE TRIGGER dados_corridas_normalize_time
BEFORE INSERT OR UPDATE ON public.dados_corridas
FOR EACH ROW EXECUTE FUNCTION public.normalize_time_columns_trigger();

-- SEÇÃO 5: TESTE (execute depois do trigger)
DO $$
DECLARE
  test_result text;
BEGIN
  RAISE NOTICE '=== TESTES ===';

  test_result := public.normalize_time_to_hhmmss('1899-12-30T05:59:36.000Z');
  RAISE NOTICE 'ISO: %', test_result;

  test_result := public.normalize_time_to_hhmmss('0.120231');
  RAISE NOTICE 'Fração: %', test_result;

  test_result := public.normalize_time_to_hhmmss('02:53:08');
  RAISE NOTICE 'HH:MM:SS: %', test_result;
END $$;

-- SEÇÃO 6: COLUNAS DERIVADAS E ÍNDICES (execute após importar dados antigos)
UPDATE public.dados_corridas
SET
  duracao_do_periodo = public.normalize_time_to_hhmmss(duracao_do_periodo),
  tempo_disponivel_escalado = public.normalize_time_to_hhmmss(tempo_disponivel_escalado),
  tempo_disponivel_absoluto = public.normalize_time_to_hhmmss(tempo_disponivel_absoluto),
  duracao_segundos = public.hhmmss_to_seconds(public.normalize_time_to_hhmmss(duracao_do_periodo)),
  tempo_disponivel_escalado_segundos = public.hhmmss_to_seconds(public.normalize_time_to_hhmmss(tempo_disponivel_escalado)),
  tempo_disponivel_absoluto_segundos = public.hhmmss_to_seconds(public.normalize_time_to_hhmmss(tempo_disponivel_absoluto));

CREATE INDEX IF NOT EXISTS idx_dados_corridas_data ON public.dados_corridas (data_do_periodo);
CREATE INDEX IF NOT EXISTS idx_dados_corridas_praca ON public.dados_corridas (praca);
CREATE INDEX IF NOT EXISTS idx_dados_corridas_sub_praca ON public.dados_corridas (sub_praca);
CREATE INDEX IF NOT EXISTS idx_dados_corridas_origem ON public.dados_corridas (origem);
CREATE INDEX IF NOT EXISTS idx_dados_corridas_semana ON public.dados_corridas ((date_part('week', data_do_periodo)));
CREATE INDEX IF NOT EXISTS idx_dados_corridas_ano_iso ON public.dados_corridas ((date_part('isoyear', data_do_periodo)));

ANALYZE public.dados_corridas;
