-- =================================================================
-- CORREÇÃO FINAL - Script Ultra-Simplificado
-- Execute este script SEÇÃO POR SEÇÃO no SQL Editor do Supabase
-- =================================================================

-- SEÇÃO 1: LIMPEZA TOTAL (execute primeiro)
DROP TABLE IF EXISTS public.dados_corridas CASCADE;

-- SEÇÃO 2: CRIAR TABELA (execute depois da limpeza)
CREATE TABLE public.dados_corridas (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    data_do_periodo DATE,
    periodo TEXT,
    duracao_do_periodo TEXT,
    numero_minimo_de_entregadores_regulares_na_escala INTEGER,
    tag TEXT,
    id_da_pessoa_entregadora TEXT,
    pessoa_entregadora TEXT,
    praca TEXT,
    sub_praca TEXT,
    origem TEXT,
    tempo_disponivel_escalado TEXT,
    tempo_disponivel_absoluto TEXT,
    numero_de_corridas_ofertadas INTEGER,
    numero_de_corridas_aceitas INTEGER,
    numero_de_corridas_rejeitadas INTEGER,
    numero_de_corridas_completadas INTEGER,
    numero_de_corridas_canceladas_pela_pessoa_entregadora INTEGER,
    numero_de_pedidos_aceitos_e_concluidos INTEGER,
    soma_das_taxas_das_corridas_aceitas NUMERIC(10,2),
    created_at TIMESTAMPTZ DEFAULT NOW()
);

-- SEÇÃO 3: PERMISSÕES (execute depois da tabela)
ALTER TABLE public.dados_corridas ENABLE ROW LEVEL SECURITY;

CREATE POLICY "Enable read access for all users"
ON public.dados_corridas
FOR SELECT
USING (true);

CREATE POLICY "Enable insert for anon users"
ON public.dados_corridas
FOR INSERT
WITH CHECK (true);

-- SEÇÃO 4: FUNÇÃO SIMPLES (execute depois das permissões)
CREATE OR REPLACE FUNCTION public.normalize_time_to_hhmmss(input_value text)
RETURNS text
LANGUAGE plpgsql
IMMUTABLE
AS $$
DECLARE
  result text := '00:00:00';
BEGIN
  IF input_value IS NULL OR trim(input_value) = '' THEN
    RETURN result;
  END IF;

  input_value := trim(input_value);

  -- Trata strings ISO
  IF input_value LIKE '%T%:%:%Z' THEN
    result := split_part(split_part(input_value, 'T', 2), '.', 1);

  -- Trata números decimais (fração de dia)
  ELSIF input_value ~ '^[0-9]+\.[0-9]+$' THEN
    DECLARE
      total_seconds int := round((input_value::numeric * 86400)::numeric);
      hours int := floor(total_seconds / 3600);
      minutes int := floor((total_seconds % 3600) / 60);
      seconds int := total_seconds % 60;
    BEGIN
      result := lpad(hours::text, 2, '0') || ':' ||
                lpad(minutes::text, 2, '0') || ':' ||
                lpad(seconds::text, 2, '0');
    END;

  -- Trata formato HH:MM:SS
  ELSIF input_value ~ '^[0-9]{1,2}:[0-9]{2}:[0-9]{2}$' THEN
    result := input_value;

  ELSE
    result := input_value;
  END IF;

  RETURN result;
END $$;

-- SEÇÃO 5: TRIGGER (execute depois da função)
CREATE OR REPLACE FUNCTION public.normalize_time_columns_trigger()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.duracao_do_periodo := public.normalize_time_to_hhmmss(NEW.duracao_do_periodo);
  NEW.tempo_disponivel_escalado := public.normalize_time_to_hhmmss(NEW.tempo_disponivel_escalado);
  NEW.tempo_disponivel_absoluto := public.normalize_time_to_hhmmss(NEW.tempo_disponivel_absoluto);
  RETURN NEW;
END $$;

CREATE TRIGGER dados_corridas_normalize_time
BEFORE INSERT OR UPDATE ON public.dados_corridas
FOR EACH ROW EXECUTE FUNCTION public.normalize_time_columns_trigger();

-- SEÇÃO 6: TESTE (execute depois do trigger)
DO $$
DECLARE
  test_result text;
BEGIN
  RAISE NOTICE '=== TESTES ===';

  test_result := public.normalize_time_to_hhmmss('1899-12-30T05:59:36.000Z');
  RAISE NOTICE 'ISO: %', test_result;

  test_result := public.normalize_time_to_hhmmss('0.120231');
  RAISE NOTICE 'Fração: %', test_result;

  test_result := public.normalize_time_to_hhmmss('02:53:08');
  RAISE NOTICE 'HH:MM:SS: %', test_result;
END $$;
